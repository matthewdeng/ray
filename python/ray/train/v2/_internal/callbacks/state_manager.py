import logging
from typing import Dict, Optional

import ray
from ray.train.base_trainer import GenDataset
from ray.train.v2._internal.execution.callback import (
    ControllerCallback,
    WorkerGroupCallback,
)
from ray.train.v2._internal.execution.context import TrainRunContext
from ray.train.v2._internal.execution.controller import TrainController
from ray.train.v2._internal.execution.controller.state import (
    ErroredState,
    FinishedState,
    RestartingState,
    TrainControllerState,
)
from ray.train.v2._internal.execution.worker_group import (
    WorkerGroup,
    WorkerGroupContext,
    WorkerGroupPollStatus,
    WorkerGroupState,
)
from ray.train.v2._internal.state.state_manager import TrainStateManager

logger = logging.getLogger(__name__)


class StateManagerCallback(ControllerCallback, WorkerGroupCallback):
    def __init__(
        self, train_run_context: TrainRunContext, datasets: Dict[str, GenDataset]
    ):
        self._state_manager = TrainStateManager()
        self._datasets = datasets  # TODO: Currently not used.
        self._run_name = train_run_context.get_run_config().name
        self._run_id = train_run_context.run_id

    def after_controller_start(self):
        # TODO: Should this be generated by the caller?
        # NOTE: These must be called on the Controller.
        #       The Callback is first initialized on the Driver.
        core_context = ray.runtime_context.get_runtime_context()
        self._job_id = core_context.get_job_id()
        self._controller_actor_id = core_context.get_actor_id()

        self._state_manager.create_train_run(
            id=self._run_id,
            name=self._run_name,
            job_id=self._job_id,
            controller_actor_id=self._controller_actor_id,
        )

    def before_worker_group_start(self, worker_group: WorkerGroup):
        self._state_manager.update_train_run_pending(
            run_id=self._run_id,
        )

        worker_group_context: WorkerGroupContext = (
            worker_group.get_worker_group_context()
        )

        if worker_group_context is None:
            logger.error(
                "WorkerGroupContext is not available. "
                "StateManagerCallback.before_worker_group_start cannot proceed."
            )
            return

        self._state_manager.create_train_run_attempt(
            run_id=self._run_id,
            attempt_id=worker_group_context.session_id,
            num_workers=worker_group_context.num_workers,
            resources_per_worker=worker_group_context.resources_per_worker,
        )

    def after_worker_group_start(self, worker_group):

        worker_group_state: WorkerGroupState = worker_group.get_worker_group_state()

        if worker_group_state is None:
            logger.error(
                "WorkerGroupState is not available. "
                "StateManagerCallback.after_worker_group_start cannot proceed."
            )
            return

        self._state_manager.update_train_run_running(
            run_id=self._run_id,
        )

        self._state_manager.update_train_run_attempt_running(
            run_id=self._run_id,
            attempt_id=worker_group_state.context.session_id,
            workers=worker_group_state.workers,
        )

    def after_controller_state_update(
        self,
        controller: TrainController,
        previous_state: TrainControllerState,
        current_state: TrainControllerState,
    ):
        error: Optional[Exception] = controller.get_training_failed_error()

        if isinstance(current_state, FinishedState):
            self._state_manager.update_train_run_finished(
                run_id=self._run_id,
            )

        elif isinstance(current_state, ErroredState):
            assert error
            self._state_manager.update_train_run_errored(
                run_id=self._run_id,
                # status_detail=error,  # TODO: Clean this up.
            )

        elif isinstance(current_state, RestartingState):
            self._state_manager.update_train_run_recovering(
                run_id=self._run_id,
            )

        # TODO: ABORT is not handled by Controller.

    def before_worker_group_shutdown(self, worker_group):

        # TODO: Implement this logic. Properly handle the errors.

        worker_group_state: WorkerGroupState = worker_group.get_worker_group_state()

        if worker_group_state is None:
            logger.error(
                "WorkerGroupState is not available. "
                "StateManagerCallback.before_worker_group_shutdown cannot proceed."
            )
            return

        # TODO: Populate WorkerGroupState with the error information.
        # Should the WorkerGroupState <> WorkerGroupStatus relationship be inversed?
        # Pass WorkerGroupState around and read WorkerGroupState.worker_group_status.

        # TODO: Set to `worker_group_state.worker_group_status` instead.
        worker_group_status: WorkerGroupPollStatus = None
        if worker_group_status is not None:
            if worker_group_status.errors:
                # ERROR CASE
                def format_errors(worker_group_status):
                    # TODO: This is a temporary solution.
                    return "\n".join(
                        [
                            f"[Rank {worker_rank}]\n{error}"
                            for worker_rank, error in worker_group_status.errors.items()
                        ]
                    )

                self._state_manager.update_train_run_attempt_errored(
                    run_id=self._run_id,
                    attempt_id=worker_group.get_worker_group_context().session_id,
                    status_detail=format_errors(worker_group_status.errors),
                )
                return

        # SUCCESS CASE

        self._state_manager.update_train_run_attempt_finished(
            run_id=self._run_id,
            attempt_id=worker_group.get_worker_group_context().session_id,
        )

    # def before_controller_shutdown(self):
    #     # TODO: Not sure if this is needed.
    #     # This may already be handled by `after_controller_state_update`.
